"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n    const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(()=>({}), {})[1];\n    const resolvedOptions = {\n        ...options,\n        onChange: (instance2, sync)=>{\n            var _a;\n            if (sync) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n            } else {\n                rerender();\n            }\n            (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n        }\n    };\n    const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions));\n    instance.setOptions(resolvedOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase({\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n        ...options\n    });\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase({\n        getScrollElement: ()=>typeof document !== \"undefined\" ? window : null,\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n        initialOffset: typeof document !== \"undefined\" ? window.scrollY : void 0,\n        ...options\n    });\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ087QUFDOEg7QUFDN0g7QUFDdkMsTUFBTVMsNEJBQTRCLE9BQU9DLGFBQWEsY0FBY1Ysa0RBQXFCLEdBQUdBLDRDQUFlO0FBQzNHLFNBQVNhLG1CQUFtQkMsT0FBTztJQUNqQyxNQUFNQyxXQUFXZiw2Q0FBZ0IsQ0FBQyxJQUFPLEVBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQ3BELE1BQU1pQixrQkFBa0I7UUFDdEIsR0FBR0gsT0FBTztRQUNWSSxVQUFVLENBQUNDLFdBQVdDO1lBQ3BCLElBQUlDO1lBQ0osSUFBSUQsTUFBTTtnQkFDUm5CLG9EQUFTQSxDQUFDYztZQUNaLE9BQU87Z0JBQ0xBO1lBQ0Y7WUFDQ00sQ0FBQUEsS0FBS1AsUUFBUUksUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJRyxHQUFHQyxJQUFJLENBQUNSLFNBQVNLLFdBQVdDO1FBQ3pFO0lBQ0Y7SUFDQSxNQUFNLENBQUNHLFNBQVMsR0FBR3ZCLDJDQUFjLENBQy9CLElBQU0sSUFBSVEsK0RBQVdBLENBQUNTO0lBRXhCTSxTQUFTRSxVQUFVLENBQUNSO0lBQ3BCakIsNENBQWUsQ0FBQztRQUNkLE9BQU91QixTQUFTRyxTQUFTO0lBQzNCLEdBQUcsRUFBRTtJQUNMakIsMEJBQTBCO1FBQ3hCLE9BQU9jLFNBQVNJLFdBQVc7SUFDN0I7SUFDQSxPQUFPSjtBQUNUO0FBQ0EsU0FBU0ssZUFBZWQsT0FBTztJQUM3QixPQUFPRCxtQkFBbUI7UUFDeEJYLGtCQUFrQkEsd0VBQUFBO1FBQ2xCQyxvQkFBb0JBLDBFQUFBQTtRQUNwQjBCLFlBQVl6QixpRUFBYUE7UUFDekIsR0FBR1UsT0FBTztJQUNaO0FBQ0Y7QUFDQSxTQUFTZ0IscUJBQXFCaEIsT0FBTztJQUNuQyxPQUFPRCxtQkFBbUI7UUFDeEJrQixrQkFBa0IsSUFBTSxPQUFPckIsYUFBYSxjQUFjc0IsU0FBUztRQUNuRTlCLG9CQUFvQkcscUVBQWlCQTtRQUNyQ0Ysc0JBQXNCRyx1RUFBbUJBO1FBQ3pDdUIsWUFBWXRCLGdFQUFZQTtRQUN4QjBCLGVBQWUsT0FBT3ZCLGFBQWEsY0FBY3NCLE9BQU9FLE9BQU8sR0FBRyxLQUFLO1FBQ3ZFLEdBQUdwQixPQUFPO0lBQ1o7QUFDRjtBQUlFLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanM/OWJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IG9ic2VydmVFbGVtZW50UmVjdCwgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsIGVsZW1lbnRTY3JvbGwsIG9ic2VydmVXaW5kb3dSZWN0LCBvYnNlcnZlV2luZG93T2Zmc2V0LCB3aW5kb3dTY3JvbGwsIFZpcnR1YWxpemVyIH0gZnJvbSBcIkB0YW5zdGFjay92aXJ0dWFsLWNvcmVcIjtcbmV4cG9ydCAqIGZyb20gXCJAdGFuc3RhY2svdmlydHVhbC1jb3JlXCI7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXJCYXNlKG9wdGlvbnMpIHtcbiAgY29uc3QgcmVyZW5kZXIgPSBSZWFjdC51c2VSZWR1Y2VyKCgpID0+ICh7fSksIHt9KVsxXTtcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25DaGFuZ2U6IChpbnN0YW5jZTIsIHN5bmMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGZsdXNoU3luYyhyZXJlbmRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXJlbmRlcigpO1xuICAgICAgfVxuICAgICAgKF9hID0gb3B0aW9ucy5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgaW5zdGFuY2UyLCBzeW5jKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IFtpbnN0YW5jZV0gPSBSZWFjdC51c2VTdGF0ZShcbiAgICAoKSA9PiBuZXcgVmlydHVhbGl6ZXIocmVzb2x2ZWRPcHRpb25zKVxuICApO1xuICBpbnN0YW5jZS5zZXRPcHRpb25zKHJlc29sdmVkT3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9kaWRNb3VudCgpO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBpbnN0YW5jZS5fd2lsbFVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogZWxlbWVudFNjcm9sbCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlV2luZG93VmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsLFxuICAgIG9ic2VydmVFbGVtZW50UmVjdDogb2JzZXJ2ZVdpbmRvd1JlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gICAgc2Nyb2xsVG9Gbjogd2luZG93U2Nyb2xsLFxuICAgIGluaXRpYWxPZmZzZXQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5zY3JvbGxZIDogdm9pZCAwLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5leHBvcnQge1xuICB1c2VWaXJ0dWFsaXplcixcbiAgdXNlV2luZG93VmlydHVhbGl6ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImZsdXNoU3luYyIsIm9ic2VydmVFbGVtZW50UmVjdCIsIm9ic2VydmVFbGVtZW50T2Zmc2V0IiwiZWxlbWVudFNjcm9sbCIsIm9ic2VydmVXaW5kb3dSZWN0Iiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIndpbmRvd1Njcm9sbCIsIlZpcnR1YWxpemVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImRvY3VtZW50IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlVmlydHVhbGl6ZXJCYXNlIiwib3B0aW9ucyIsInJlcmVuZGVyIiwidXNlUmVkdWNlciIsInJlc29sdmVkT3B0aW9ucyIsIm9uQ2hhbmdlIiwiaW5zdGFuY2UyIiwic3luYyIsIl9hIiwiY2FsbCIsImluc3RhbmNlIiwidXNlU3RhdGUiLCJzZXRPcHRpb25zIiwiX2RpZE1vdW50IiwiX3dpbGxVcGRhdGUiLCJ1c2VWaXJ0dWFsaXplciIsInNjcm9sbFRvRm4iLCJ1c2VXaW5kb3dWaXJ0dWFsaXplciIsImdldFNjcm9sbEVsZW1lbnQiLCJ3aW5kb3ciLCJpbml0aWFsT2Zmc2V0Iiwic2Nyb2xsWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst defaultKeyExtractor = (index)=>index;\nconst defaultRangeExtractor = (range)=>{\n    const start = Math.max(range.startIndex - range.overscan, 0);\n    const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    const arr = [];\n    for(let i = start; i <= end; i++){\n        arr.push(i);\n    }\n    return arr;\n};\nconst observeElementRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = (rect)=>{\n        const { width, height } = rect;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    if (typeof ResizeObserver === \"undefined\") {\n        return ()=>{};\n    }\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        if (entry == null ? void 0 : entry.borderBoxSize) {\n            const box = entry.borderBoxSize[0];\n            if (box) {\n                handler({\n                    width: box.inlineSize,\n                    height: box.blockSize\n                });\n                return;\n            }\n        }\n        handler(element.getBoundingClientRect());\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return ()=>{\n        observer.unobserve(element);\n    };\n};\nconst observeWindowRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, {\n        passive: true\n    });\n    return ()=>{\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nconst observeElementOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n    };\n    handler();\n    element.addEventListener(\"scroll\", handler, {\n        passive: true\n    });\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n    };\n};\nconst observeWindowOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb(element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"]);\n    };\n    handler();\n    element.addEventListener(\"scroll\", handler, {\n        passive: true\n    });\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n    };\n};\nconst measureElement = (element, entry, instance)=>{\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n            const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst windowScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nconst elementScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nclass Virtualizer {\n    constructor(opts){\n        this.unsubs = [];\n        this.scrollElement = null;\n        this.isScrolling = false;\n        this.isScrollingTimeoutId = null;\n        this.scrollToIndexTimeoutId = null;\n        this.measurementsCache = [];\n        this.itemSizeCache = /* @__PURE__ */ new Map();\n        this.pendingMeasuredCacheIndexes = [];\n        this.scrollDirection = null;\n        this.scrollAdjustments = 0;\n        this.measureElementCache = /* @__PURE__ */ new Map();\n        this.observer = /* @__PURE__ */ (()=>{\n            let _ro = null;\n            const get = ()=>{\n                if (_ro) {\n                    return _ro;\n                } else if (typeof ResizeObserver !== \"undefined\") {\n                    return _ro = new ResizeObserver((entries)=>{\n                        entries.forEach((entry)=>{\n                            this._measureElement(entry.target, entry);\n                        });\n                    });\n                } else {\n                    return null;\n                }\n            };\n            return {\n                disconnect: ()=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.disconnect();\n                },\n                observe: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.observe(target, {\n                        box: \"border-box\"\n                    });\n                },\n                unobserve: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.unobserve(target);\n                }\n            };\n        })();\n        this.range = null;\n        this.setOptions = (opts2)=>{\n            Object.entries(opts2).forEach(([key, value])=>{\n                if (typeof value === \"undefined\") delete opts2[key];\n            });\n            this.options = {\n                debug: false,\n                initialOffset: 0,\n                overscan: 1,\n                paddingStart: 0,\n                paddingEnd: 0,\n                scrollPaddingStart: 0,\n                scrollPaddingEnd: 0,\n                horizontal: false,\n                getItemKey: defaultKeyExtractor,\n                rangeExtractor: defaultRangeExtractor,\n                onChange: ()=>{},\n                measureElement,\n                initialRect: {\n                    width: 0,\n                    height: 0\n                },\n                scrollMargin: 0,\n                scrollingDelay: 150,\n                indexAttribute: \"data-index\",\n                initialMeasurementsCache: [],\n                lanes: 1,\n                ...opts2\n            };\n        };\n        this.notify = (sync)=>{\n            var _a, _b;\n            (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n        };\n        this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>{\n            this.calculateRange();\n            return [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ];\n        }, (isScrolling)=>{\n            this.notify(isScrolling);\n        }, {\n            key:  true && \"maybeNotify\",\n            debug: ()=>this.options.debug,\n            initialDeps: [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ]\n        });\n        this.cleanup = ()=>{\n            this.unsubs.filter(Boolean).forEach((d)=>d());\n            this.unsubs = [];\n            this.scrollElement = null;\n        };\n        this._didMount = ()=>{\n            this.measureElementCache.forEach(this.observer.observe);\n            return ()=>{\n                this.observer.disconnect();\n                this.cleanup();\n            };\n        };\n        this._willUpdate = ()=>{\n            const scrollElement = this.options.getScrollElement();\n            if (this.scrollElement !== scrollElement) {\n                this.cleanup();\n                this.scrollElement = scrollElement;\n                this._scrollToOffset(this.scrollOffset, {\n                    adjustments: void 0,\n                    behavior: void 0\n                });\n                this.unsubs.push(this.options.observeElementRect(this, (rect)=>{\n                    this.scrollRect = rect;\n                    this.maybeNotify();\n                }));\n                this.unsubs.push(this.options.observeElementOffset(this, (offset)=>{\n                    this.scrollAdjustments = 0;\n                    if (this.scrollOffset === offset) {\n                        return;\n                    }\n                    if (this.isScrollingTimeoutId !== null) {\n                        clearTimeout(this.isScrollingTimeoutId);\n                        this.isScrollingTimeoutId = null;\n                    }\n                    this.isScrolling = true;\n                    this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n                    this.scrollOffset = offset;\n                    this.maybeNotify();\n                    this.isScrollingTimeoutId = setTimeout(()=>{\n                        this.isScrollingTimeoutId = null;\n                        this.isScrolling = false;\n                        this.scrollDirection = null;\n                        this.maybeNotify();\n                    }, this.options.scrollingDelay);\n                }));\n            }\n        };\n        this.getSize = ()=>{\n            return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n        };\n        this.memoOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.count,\n                this.options.paddingStart,\n                this.options.scrollMargin,\n                this.options.getItemKey\n            ], (count, paddingStart, scrollMargin, getItemKey)=>{\n            this.pendingMeasuredCacheIndexes = [];\n            return {\n                count,\n                paddingStart,\n                scrollMargin,\n                getItemKey\n            };\n        }, {\n            key: false\n        });\n        this.getFurthestMeasurement = (measurements, index)=>{\n            const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n            const furthestMeasurements = /* @__PURE__ */ new Map();\n            for(let m = index - 1; m >= 0; m--){\n                const measurement = measurements[m];\n                if (furthestMeasurementsFound.has(measurement.lane)) {\n                    continue;\n                }\n                const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n                if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                    furthestMeasurements.set(measurement.lane, measurement);\n                } else if (measurement.end < previousFurthestMeasurement.end) {\n                    furthestMeasurementsFound.set(measurement.lane, true);\n                }\n                if (furthestMeasurementsFound.size === this.options.lanes) {\n                    break;\n                }\n            }\n            return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b)=>{\n                if (a.end === b.end) {\n                    return a.index - b.index;\n                }\n                return a.end - b.end;\n            })[0] : void 0;\n        };\n        this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.memoOptions(),\n                this.itemSizeCache\n            ], ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache)=>{\n            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n            this.pendingMeasuredCacheIndexes = [];\n            const measurements = this.measurementsCache.slice(0, min);\n            for(let i = min; i < count; i++){\n                const key = getItemKey(i);\n                const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n                const start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;\n                const measuredSize = itemSizeCache.get(key);\n                const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n                const end = start + size;\n                const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n                measurements[i] = {\n                    index: i,\n                    start,\n                    size,\n                    end,\n                    key,\n                    lane\n                };\n            }\n            this.measurementsCache = measurements;\n            return measurements;\n        }, {\n            key:  true && \"getMeasurements\",\n            debug: ()=>this.options.debug\n        });\n        this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurements(),\n                this.getSize(),\n                this.scrollOffset\n            ], (measurements, outerSize, scrollOffset)=>{\n            return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n                measurements,\n                outerSize,\n                scrollOffset\n            }) : null;\n        }, {\n            key:  true && \"calculateRange\",\n            debug: ()=>this.options.debug\n        });\n        this.getIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.rangeExtractor,\n                this.calculateRange(),\n                this.options.overscan,\n                this.options.count\n            ], (rangeExtractor, range, overscan, count)=>{\n            return range === null ? [] : rangeExtractor({\n                ...range,\n                overscan,\n                count\n            });\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.indexFromElement = (node)=>{\n            const attributeName = this.options.indexAttribute;\n            const indexStr = node.getAttribute(attributeName);\n            if (!indexStr) {\n                console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n                return -1;\n            }\n            return parseInt(indexStr, 10);\n        };\n        this._measureElement = (node, entry)=>{\n            const item = this.measurementsCache[this.indexFromElement(node)];\n            if (!item || !node.isConnected) {\n                this.measureElementCache.forEach((cached, key)=>{\n                    if (cached === node) {\n                        this.observer.unobserve(node);\n                        this.measureElementCache.delete(key);\n                    }\n                });\n                return;\n            }\n            const prevNode = this.measureElementCache.get(item.key);\n            if (prevNode !== node) {\n                if (prevNode) {\n                    this.observer.unobserve(prevNode);\n                }\n                this.observer.observe(node);\n                this.measureElementCache.set(item.key, node);\n            }\n            const measuredItemSize = this.options.measureElement(node, entry, this);\n            this.resizeItem(item, measuredItemSize);\n        };\n        this.resizeItem = (item, size)=>{\n            const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n            const delta = size - itemSize;\n            if (delta !== 0) {\n                if (item.start < this.scrollOffset + this.scrollAdjustments) {\n                    if ( true && this.options.debug) {\n                        console.info(\"correction\", delta);\n                    }\n                    this._scrollToOffset(this.scrollOffset, {\n                        adjustments: this.scrollAdjustments += delta,\n                        behavior: void 0\n                    });\n                }\n                this.pendingMeasuredCacheIndexes.push(item.index);\n                this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n                this.notify(false);\n            }\n        };\n        this.measureElement = (node)=>{\n            if (!node) {\n                return;\n            }\n            this._measureElement(node, void 0);\n        };\n        this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getIndexes(),\n                this.getMeasurements()\n            ], (indexes, measurements)=>{\n            const virtualItems = [];\n            for(let k = 0, len = indexes.length; k < len; k++){\n                const i = indexes[k];\n                const measurement = measurements[i];\n                virtualItems.push(measurement);\n            }\n            return virtualItems;\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualItemForOffset = (offset)=>{\n            const measurements = this.getMeasurements();\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[findNearestBinarySearch(0, measurements.length - 1, (index)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start, offset)]);\n        };\n        this.getOffsetForAlignment = (toOffset, align)=>{\n            const size = this.getSize();\n            if (align === \"auto\") {\n                if (toOffset <= this.scrollOffset) {\n                    align = \"start\";\n                } else if (toOffset >= this.scrollOffset + size) {\n                    align = \"end\";\n                } else {\n                    align = \"start\";\n                }\n            }\n            if (align === \"start\") {\n                toOffset = toOffset;\n            } else if (align === \"end\") {\n                toOffset = toOffset - size;\n            } else if (align === \"center\") {\n                toOffset = toOffset - size / 2;\n            }\n            const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n            const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n            const maxOffset = scrollSize - this.getSize();\n            return Math.max(Math.min(maxOffset, toOffset), 0);\n        };\n        this.getOffsetForIndex = (index, align = \"auto\")=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            const measurement = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(this.getMeasurements()[index]);\n            if (align === \"auto\") {\n                if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n                    align = \"end\";\n                } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n                    align = \"start\";\n                } else {\n                    return [\n                        this.scrollOffset,\n                        align\n                    ];\n                }\n            }\n            const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n            return [\n                this.getOffsetForAlignment(toOffset, align),\n                align\n            ];\n        };\n        this.isDynamicMode = ()=>this.measureElementCache.size > 0;\n        this.cancelScrollToIndex = ()=>{\n            if (this.scrollToIndexTimeoutId !== null) {\n                clearTimeout(this.scrollToIndexTimeoutId);\n                this.scrollToIndexTimeoutId = null;\n            }\n        };\n        this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {})=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n            this._scrollToOffset(toOffset, {\n                adjustments: void 0,\n                behavior\n            });\n            if (behavior !== \"smooth\" && this.isDynamicMode()) {\n                this.scrollToIndexTimeoutId = setTimeout(()=>{\n                    this.scrollToIndexTimeoutId = null;\n                    const elementInDOM = this.measureElementCache.has(this.options.getItemKey(index));\n                    if (elementInDOM) {\n                        const [toOffset2] = this.getOffsetForIndex(index, align);\n                        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(toOffset2, this.scrollOffset)) {\n                            this.scrollToIndex(index, {\n                                align,\n                                behavior\n                            });\n                        }\n                    } else {\n                        this.scrollToIndex(index, {\n                            align,\n                            behavior\n                        });\n                    }\n                });\n            }\n        };\n        this.scrollBy = (delta, { behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.scrollOffset + delta, {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.getTotalSize = ()=>{\n            var _a;\n            const measurements = this.getMeasurements();\n            let end;\n            if (measurements.length === 0) {\n                end = this.options.paddingStart;\n            } else {\n                end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map((m)=>m.end));\n            }\n            return end - this.options.scrollMargin + this.options.paddingEnd;\n        };\n        this._scrollToOffset = (offset, { adjustments, behavior })=>{\n            this.options.scrollToFn(offset, {\n                behavior,\n                adjustments\n            }, this);\n        };\n        this.measure = ()=>{\n            this.itemSizeCache = /* @__PURE__ */ new Map();\n            this.notify(false);\n        };\n        this.setOptions(opts);\n        this.scrollRect = this.options.initialRect;\n        this.scrollOffset = this.options.initialOffset;\n        this.measurementsCache = this.options.initialMeasurementsCache;\n        this.measurementsCache.forEach((item)=>{\n            this.itemSizeCache.set(item.key, item.size);\n        });\n        this.maybeNotify();\n    }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value)=>{\n    while(low <= high){\n        const middle = (low + high) / 2 | 0;\n        const currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n    const count = measurements.length - 1;\n    const getOffset = (index)=>measurements[index].start;\n    const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n    let endIndex = startIndex;\n    while(endIndex < count && measurements[endIndex].end < scrollOffset + outerSize){\n        endIndex++;\n    }\n    return {\n        startIndex,\n        endIndex\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUM3RCxNQUFNRyxzQkFBc0IsQ0FBQ0MsUUFBVUE7QUFDdkMsTUFBTUMsd0JBQXdCLENBQUNDO0lBQzdCLE1BQU1DLFFBQVFDLEtBQUtDLEdBQUcsQ0FBQ0gsTUFBTUksVUFBVSxHQUFHSixNQUFNSyxRQUFRLEVBQUU7SUFDMUQsTUFBTUMsTUFBTUosS0FBS0ssR0FBRyxDQUFDUCxNQUFNUSxRQUFRLEdBQUdSLE1BQU1LLFFBQVEsRUFBRUwsTUFBTVMsS0FBSyxHQUFHO0lBQ3BFLE1BQU1DLE1BQU0sRUFBRTtJQUNkLElBQUssSUFBSUMsSUFBSVYsT0FBT1UsS0FBS0wsS0FBS0ssSUFBSztRQUNqQ0QsSUFBSUUsSUFBSSxDQUFDRDtJQUNYO0lBQ0EsT0FBT0Q7QUFDVDtBQUNBLE1BQU1HLHFCQUFxQixDQUFDQyxVQUFVQztJQUNwQyxNQUFNQyxVQUFVRixTQUFTRyxhQUFhO0lBQ3RDLElBQUksQ0FBQ0QsU0FBUztRQUNaO0lBQ0Y7SUFDQSxNQUFNRSxVQUFVLENBQUNDO1FBQ2YsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtRQUMxQkosR0FBRztZQUFFSyxPQUFPbEIsS0FBS29CLEtBQUssQ0FBQ0Y7WUFBUUMsUUFBUW5CLEtBQUtvQixLQUFLLENBQUNEO1FBQVE7SUFDNUQ7SUFDQUgsUUFBUUYsUUFBUU8scUJBQXFCO0lBQ3JDLElBQUksT0FBT0MsbUJBQW1CLGFBQWE7UUFDekMsT0FBTyxLQUNQO0lBQ0Y7SUFDQSxNQUFNQyxXQUFXLElBQUlELGVBQWUsQ0FBQ0U7UUFDbkMsTUFBTUMsUUFBUUQsT0FBTyxDQUFDLEVBQUU7UUFDeEIsSUFBSUMsU0FBUyxPQUFPLEtBQUssSUFBSUEsTUFBTUMsYUFBYSxFQUFFO1lBQ2hELE1BQU1DLE1BQU1GLE1BQU1DLGFBQWEs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aUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcz9iNjlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1lbW8sIG5vdFVuZGVmaW5lZCwgYXBwcm94RXF1YWwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgZGVmYXVsdEtleUV4dHJhY3RvciA9IChpbmRleCkgPT4gaW5kZXg7XG5jb25zdCBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IgPSAocmFuZ2UpID0+IHtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChyYW5nZS5zdGFydEluZGV4IC0gcmFuZ2Uub3ZlcnNjYW4sIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihyYW5nZS5lbmRJbmRleCArIHJhbmdlLm92ZXJzY2FuLCByYW5nZS5jb3VudCAtIDEpO1xuICBjb25zdCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgYXJyLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5jb25zdCBvYnNlcnZlRWxlbWVudFJlY3QgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IChyZWN0KSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgIGNiKHsgd2lkdGg6IE1hdGgucm91bmQod2lkdGgpLCBoZWlnaHQ6IE1hdGgucm91bmQoaGVpZ2h0KSB9KTtcbiAgfTtcbiAgaGFuZGxlcihlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBpZiAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmJvcmRlckJveFNpemUpIHtcbiAgICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgICBpZiAoYm94KSB7XG4gICAgICAgIGhhbmRsZXIoeyB3aWR0aDogYm94LmlubGluZVNpemUsIGhlaWdodDogYm94LmJsb2NrU2l6ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVyKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufTtcbmNvbnN0IG9ic2VydmVXaW5kb3dSZWN0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgY2IoeyB3aWR0aDogZWxlbWVudC5pbm5lcldpZHRoLCBoZWlnaHQ6IGVsZW1lbnQuaW5uZXJIZWlnaHQgfSk7XG4gIH07XG4gIGhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZXIsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBvYnNlcnZlRWxlbWVudE9mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgIGNiKGVsZW1lbnRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiXSk7XG4gIH07XG4gIGhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBvYnNlcnZlV2luZG93T2Zmc2V0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgY2IoZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFhcIiA6IFwic2Nyb2xsWVwiXSk7XG4gIH07XG4gIGhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBtZWFzdXJlRWxlbWVudCA9IChlbGVtZW50LCBlbnRyeSwgaW5zdGFuY2UpID0+IHtcbiAgaWYgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5ib3JkZXJCb3hTaXplKSB7XG4gICAgY29uc3QgYm94ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXTtcbiAgICBpZiAoYm94KSB7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5yb3VuZChcbiAgICAgICAgYm94W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwiaW5saW5lU2l6ZVwiIDogXCJibG9ja1NpemVcIl1cbiAgICAgICk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXVxuICApO1xufTtcbmNvbnN0IHdpbmRvd1Njcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jb25zdCBlbGVtZW50U2Nyb2xsID0gKG9mZnNldCwge1xuICBhZGp1c3RtZW50cyA9IDAsXG4gIGJlaGF2aW9yXG59LCBpbnN0YW5jZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2IgPSAoX2EgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2Nyb2xsVG8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl06IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yXG4gIH0pO1xufTtcbmNsYXNzIFZpcnR1YWxpemVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudW5zdWJzID0gW107XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW107XG4gICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICAgIGxldCBfcm8gPSBudWxsO1xuICAgICAgY29uc3QgZ2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoX3JvKSB7XG4gICAgICAgICAgcmV0dXJuIF9ybztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gX3JvID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2JzZXJ2ZTogKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5vYnNlcnZlKHRhcmdldCwgeyBib3g6IFwiYm9yZGVyLWJveFwiIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bm9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5vYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnNldE9wdGlvbnMgPSAob3B0czIpID0+IHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG9wdHMyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICBkZWxldGUgb3B0czJba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWxPZmZzZXQ6IDAsXG4gICAgICAgIG92ZXJzY2FuOiAxLFxuICAgICAgICBwYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ0VuZDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIGdldEl0ZW1LZXk6IGRlZmF1bHRLZXlFeHRyYWN0b3IsXG4gICAgICAgIHJhbmdlRXh0cmFjdG9yOiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVFbGVtZW50LFxuICAgICAgICBpbml0aWFsUmVjdDogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIHNjcm9sbE1hcmdpbjogMCxcbiAgICAgICAgc2Nyb2xsaW5nRGVsYXk6IDE1MCxcbiAgICAgICAgaW5kZXhBdHRyaWJ1dGU6IFwiZGF0YS1pbmRleFwiLFxuICAgICAgICBpbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU6IFtdLFxuICAgICAgICBsYW5lczogMSxcbiAgICAgICAgLi4ub3B0czJcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vdGlmeSA9IChzeW5jKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMsIHN5bmMpO1xuICAgIH07XG4gICAgdGhpcy5tYXliZU5vdGlmeSA9IG1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIChpc1Njcm9sbGluZykgPT4ge1xuICAgICAgICB0aGlzLm5vdGlmeShpc1Njcm9sbGluZyk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcIm1heWJlTm90aWZ5XCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgICAgIGluaXRpYWxEZXBzOiBbXG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5zdGFydEluZGV4IDogbnVsbCxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5lbmRJbmRleCA6IG51bGxcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuX2RpZE1vdW50ID0gKCkgPT4ge1xuICAgICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmZvckVhY2godGhpcy5vYnNlcnZlci5vYnNlcnZlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLl93aWxsVXBkYXRlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICE9PSBzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLnNjcm9sbE9mZnNldCwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRSZWN0KHRoaXMsIChyZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9ic2VydmVFbGVtZW50T2Zmc2V0KHRoaXMsIChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsT2Zmc2V0ID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSB0aGlzLnNjcm9sbE9mZnNldCA8IG9mZnNldCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNjcm9sbGluZ0RlbGF5KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuICAgIH07XG4gICAgdGhpcy5tZW1vT3B0aW9ucyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbixcbiAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXlcbiAgICAgIF0sXG4gICAgICAoY291bnQsIHBhZGRpbmdTdGFydCwgc2Nyb2xsTWFyZ2luLCBnZXRJdGVtS2V5KSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY291bnQsXG4gICAgICAgICAgcGFkZGluZ1N0YXJ0LFxuICAgICAgICAgIHNjcm9sbE1hcmdpbixcbiAgICAgICAgICBnZXRJdGVtS2V5XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQgPSAobWVhc3VyZW1lbnRzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCBtID0gaW5kZXggLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1ttXTtcbiAgICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuaGFzKG1lYXN1cmVtZW50LmxhbmUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID0gZnVydGhlc3RNZWFzdXJlbWVudHMuZ2V0KFxuICAgICAgICAgIG1lYXN1cmVtZW50LmxhbmVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9PSBudWxsIHx8IG1lYXN1cmVtZW50LmVuZCA+IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zZXQobWVhc3VyZW1lbnQubGFuZSwgbWVhc3VyZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LmVuZCA8IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNldChtZWFzdXJlbWVudC5sYW5lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcyA/IEFycmF5LmZyb20oZnVydGhlc3RNZWFzdXJlbWVudHMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEuZW5kID09PSBiLmVuZCkge1xuICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5lbmQgLSBiLmVuZDtcbiAgICAgIH0pWzBdIDogdm9pZCAwO1xuICAgIH07XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMubWVtb09wdGlvbnMoKSwgdGhpcy5pdGVtU2l6ZUNhY2hlXSxcbiAgICAgICh7IGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSB9LCBpdGVtU2l6ZUNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi50aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcykgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0SXRlbUtleShpKTtcbiAgICAgICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50ID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gbWVhc3VyZW1lbnRzW2kgLSAxXSA6IHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudChtZWFzdXJlbWVudHMsIGkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQuZW5kIDogcGFkZGluZ1N0YXJ0ICsgc2Nyb2xsTWFyZ2luO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVkU2l6ZSA9IGl0ZW1TaXplQ2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IHR5cGVvZiBtZWFzdXJlZFNpemUgPT09IFwibnVtYmVyXCIgPyBtZWFzdXJlZFNpemUgOiB0aGlzLm9wdGlvbnMuZXN0aW1hdGVTaXplKGkpO1xuICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgc2l6ZTtcbiAgICAgICAgICBjb25zdCBsYW5lID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQubGFuZSA6IGkgJSB0aGlzLm9wdGlvbnMubGFuZXM7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBsYW5lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gbWVhc3VyZW1lbnRzO1xuICAgICAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJnZXRNZWFzdXJlbWVudHNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jYWxjdWxhdGVSYW5nZSA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudHMoKSwgdGhpcy5nZXRTaXplKCksIHRoaXMuc2Nyb2xsT2Zmc2V0XSxcbiAgICAgIChtZWFzdXJlbWVudHMsIG91dGVyU2l6ZSwgc2Nyb2xsT2Zmc2V0KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlID0gbWVhc3VyZW1lbnRzLmxlbmd0aCA+IDAgJiYgb3V0ZXJTaXplID4gMCA/IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgICAgICBtZWFzdXJlbWVudHMsXG4gICAgICAgICAgb3V0ZXJTaXplLFxuICAgICAgICAgIHNjcm9sbE9mZnNldFxuICAgICAgICB9KSA6IG51bGw7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImNhbGN1bGF0ZVJhbmdlXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0SW5kZXhlcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5yYW5nZUV4dHJhY3RvcixcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSYW5nZSgpLFxuICAgICAgICB0aGlzLm9wdGlvbnMub3ZlcnNjYW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudFxuICAgICAgXSxcbiAgICAgIChyYW5nZUV4dHJhY3RvciwgcmFuZ2UsIG92ZXJzY2FuLCBjb3VudCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UgPT09IG51bGwgPyBbXSA6IHJhbmdlRXh0cmFjdG9yKHtcbiAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgICBvdmVyc2NhbixcbiAgICAgICAgICBjb3VudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0SW5kZXhlc1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmluZGV4RnJvbUVsZW1lbnQgPSAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMub3B0aW9ucy5pbmRleEF0dHJpYnV0ZTtcbiAgICAgIGNvbnN0IGluZGV4U3RyID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBpZiAoIWluZGV4U3RyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgTWlzc2luZyBhdHRyaWJ1dGUgbmFtZSAnJHthdHRyaWJ1dGVOYW1lfT17aW5kZXh9JyBvbiBtZWFzdXJlZCBlbGVtZW50LmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlSW50KGluZGV4U3RyLCAxMCk7XG4gICAgfTtcbiAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IChub2RlLCBlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpXTtcbiAgICAgIGlmICghaXRlbSB8fCAhbm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZm9yRWFjaCgoY2FjaGVkLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoY2FjaGVkID09PSBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5nZXQoaXRlbS5rZXkpO1xuICAgICAgaWYgKHByZXZOb2RlICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKHByZXZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICAgIHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5zZXQoaXRlbS5rZXksIG5vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVhc3VyZWRJdGVtU2l6ZSA9IHRoaXMub3B0aW9ucy5tZWFzdXJlRWxlbWVudChub2RlLCBlbnRyeSwgdGhpcyk7XG4gICAgICB0aGlzLnJlc2l6ZUl0ZW0oaXRlbSwgbWVhc3VyZWRJdGVtU2l6ZSk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZUl0ZW0gPSAoaXRlbSwgc2l6ZSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplQ2FjaGUuZ2V0KGl0ZW0ua2V5KSA/PyBpdGVtLnNpemU7XG4gICAgICBjb25zdCBkZWx0YSA9IHNpemUgLSBpdGVtU2l6ZTtcbiAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICBpZiAoaXRlbS5zdGFydCA8IHRoaXMuc2Nyb2xsT2Zmc2V0ICsgdGhpcy5zY3JvbGxBZGp1c3RtZW50cykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJjb3JyZWN0aW9uXCIsIGRlbHRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5zY3JvbGxPZmZzZXQsIHtcbiAgICAgICAgICAgIGFkanVzdG1lbnRzOiB0aGlzLnNjcm9sbEFkanVzdG1lbnRzICs9IGRlbHRhLFxuICAgICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaXRlbS5pbmRleCk7XG4gICAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAodGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgc2l6ZSkpO1xuICAgICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVFbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChub2RlLCB2b2lkIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbXMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0SW5kZXhlcygpLCB0aGlzLmdldE1lYXN1cmVtZW50cygpXSxcbiAgICAgIChpbmRleGVzLCBtZWFzdXJlbWVudHMpID0+IHtcbiAgICAgICAgY29uc3QgdmlydHVhbEl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBpbmRleGVzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgY29uc3QgaSA9IGluZGV4ZXNba107XG4gICAgICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgICAgICAgdmlydHVhbEl0ZW1zLnB1c2gobWVhc3VyZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXJ0dWFsSXRlbXM7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldEluZGV4ZXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbUZvck9mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICByZXR1cm4gbm90VW5kZWZpbmVkKFxuICAgICAgICBtZWFzdXJlbWVudHNbZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goXG4gICAgICAgICAgMCxcbiAgICAgICAgICBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAoaW5kZXgpID0+IG5vdFVuZGVmaW5lZChtZWFzdXJlbWVudHNbaW5kZXhdKS5zdGFydCxcbiAgICAgICAgICBvZmZzZXRcbiAgICAgICAgKV1cbiAgICAgICk7XG4gICAgfTtcbiAgICB0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCA9ICh0b09mZnNldCwgYWxpZ24pID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKHRvT2Zmc2V0IDw9IHRoaXMuc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodG9PZmZzZXQgPj0gdGhpcy5zY3JvbGxPZmZzZXQgKyBzaXplKSB7XG4gICAgICAgICAgYWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWxpZ24gPT09IFwic3RhcnRcIikge1xuICAgICAgICB0b09mZnNldCA9IHRvT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgICB0b09mZnNldCA9IHRvT2Zmc2V0IC0gc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgPSB0b09mZnNldCAtIHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZVByb3AgPSB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwic2Nyb2xsV2lkdGhcIiA6IFwic2Nyb2xsSGVpZ2h0XCI7XG4gICAgICBjb25zdCBzY3JvbGxTaXplID0gdGhpcy5zY3JvbGxFbGVtZW50ID8gXCJkb2N1bWVudFwiIGluIHRoaXMuc2Nyb2xsRWxlbWVudCA/IHRoaXMuc2Nyb2xsRWxlbWVudC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbc2Nyb2xsU2l6ZVByb3BdIDogdGhpcy5zY3JvbGxFbGVtZW50W3Njcm9sbFNpemVQcm9wXSA6IDA7XG4gICAgICBjb25zdCBtYXhPZmZzZXQgPSBzY3JvbGxTaXplIC0gdGhpcy5nZXRTaXplKCk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4T2Zmc2V0LCB0b09mZnNldCksIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JJbmRleCA9IChpbmRleCwgYWxpZ24gPSBcImF1dG9cIikgPT4ge1xuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBub3RVbmRlZmluZWQodGhpcy5nZXRNZWFzdXJlbWVudHMoKVtpbmRleF0pO1xuICAgICAgaWYgKGFsaWduID09PSBcImF1dG9cIikge1xuICAgICAgICBpZiAobWVhc3VyZW1lbnQuZW5kID49IHRoaXMuc2Nyb2xsT2Zmc2V0ICsgdGhpcy5nZXRTaXplKCkgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCkge1xuICAgICAgICAgIGFsaWduID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChtZWFzdXJlbWVudC5zdGFydCA8PSB0aGlzLnNjcm9sbE9mZnNldCArIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3RoaXMuc2Nyb2xsT2Zmc2V0LCBhbGlnbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvT2Zmc2V0ID0gYWxpZ24gPT09IFwiZW5kXCIgPyBtZWFzdXJlbWVudC5lbmQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCA6IG1lYXN1cmVtZW50LnN0YXJ0IC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydDtcbiAgICAgIHJldHVybiBbdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwgYWxpZ25dO1xuICAgIH07XG4gICAgdGhpcy5pc0R5bmFtaWNNb2RlID0gKCkgPT4gdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLnNpemUgPiAwO1xuICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvT2Zmc2V0ID0gKHRvT2Zmc2V0LCB7IGFsaWduID0gXCJzdGFydFwiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXggPSAoaW5kZXgsIHsgYWxpZ246IGluaXRpYWxBbGlnbiA9IFwiYXV0b1wiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgW3RvT2Zmc2V0LCBhbGlnbl0gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBpbml0aWFsQWxpZ24pO1xuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodG9PZmZzZXQsIHsgYWRqdXN0bWVudHM6IHZvaWQgMCwgYmVoYXZpb3IgfSk7XG4gICAgICBpZiAoYmVoYXZpb3IgIT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBlbGVtZW50SW5ET00gPSB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuaGFzKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXkoaW5kZXgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZWxlbWVudEluRE9NKSB7XG4gICAgICAgICAgICBjb25zdCBbdG9PZmZzZXQyXSA9IHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGFsaWduKTtcbiAgICAgICAgICAgIGlmICghYXBwcm94RXF1YWwodG9PZmZzZXQyLCB0aGlzLnNjcm9sbE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7IGFsaWduLCBiZWhhdmlvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7IGFsaWduLCBiZWhhdmlvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxCeSA9IChkZWx0YSwgeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5zY3JvbGxPZmZzZXQgKyBkZWx0YSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBsZXQgZW5kO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZW5kID0gdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSA/ICgoX2EgPSBtZWFzdXJlbWVudHNbbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW5kKSA/PyAwIDogTWF0aC5tYXgoXG4gICAgICAgICAgLi4ubWVhc3VyZW1lbnRzLnNsaWNlKC10aGlzLm9wdGlvbnMubGFuZXMpLm1hcCgobSkgPT4gbS5lbmQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5kIC0gdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbiArIHRoaXMub3B0aW9ucy5wYWRkaW5nRW5kO1xuICAgIH07XG4gICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQgPSAob2Zmc2V0LCB7XG4gICAgICBhZGp1c3RtZW50cyxcbiAgICAgIGJlaGF2aW9yXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvRm4ob2Zmc2V0LCB7IGJlaGF2aW9yLCBhZGp1c3RtZW50cyB9LCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0cyk7XG4gICAgdGhpcy5zY3JvbGxSZWN0ID0gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQ7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IHRoaXMub3B0aW9ucy5pbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBpdGVtLnNpemUpO1xuICAgIH0pO1xuICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgfVxufVxuY29uc3QgZmluZE5lYXJlc3RCaW5hcnlTZWFyY2ggPSAobG93LCBoaWdoLCBnZXRDdXJyZW50VmFsdWUsIHZhbHVlKSA9PiB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IChsb3cgKyBoaWdoKSAvIDIgfCAwO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZShtaWRkbGUpO1xuICAgIGlmIChjdXJyZW50VmFsdWUgPCB2YWx1ZSkge1xuICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSA+IHZhbHVlKSB7XG4gICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9XG4gIH1cbiAgaWYgKGxvdyA+IDApIHtcbiAgICByZXR1cm4gbG93IC0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVJhbmdlKHtcbiAgbWVhc3VyZW1lbnRzLFxuICBvdXRlclNpemUsXG4gIHNjcm9sbE9mZnNldFxufSkge1xuICBjb25zdCBjb3VudCA9IG1lYXN1cmVtZW50cy5sZW5ndGggLSAxO1xuICBjb25zdCBnZXRPZmZzZXQgPSAoaW5kZXgpID0+IG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQ7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCgwLCBjb3VudCwgZ2V0T2Zmc2V0LCBzY3JvbGxPZmZzZXQpO1xuICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4O1xuICB3aGlsZSAoZW5kSW5kZXggPCBjb3VudCAmJiBtZWFzdXJlbWVudHNbZW5kSW5kZXhdLmVuZCA8IHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSkge1xuICAgIGVuZEluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHsgc3RhcnRJbmRleCwgZW5kSW5kZXggfTtcbn1cbmV4cG9ydCB7XG4gIFZpcnR1YWxpemVyLFxuICBhcHByb3hFcXVhbCxcbiAgZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICBlbGVtZW50U2Nyb2xsLFxuICBtZWFzdXJlRWxlbWVudCxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkLFxuICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgb2JzZXJ2ZUVsZW1lbnRSZWN0LFxuICBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICBvYnNlcnZlV2luZG93UmVjdCxcbiAgd2luZG93U2Nyb2xsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsibWVtbyIsIm5vdFVuZGVmaW5lZCIsImFwcHJveEVxdWFsIiwiZGVmYXVsdEtleUV4dHJhY3RvciIsImluZGV4IiwiZGVmYXVsdFJhbmdlRXh0cmFjdG9yIiwicmFuZ2UiLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJzdGFydEluZGV4Iiwib3ZlcnNjYW4iLCJlbmQiLCJtaW4iLCJlbmRJbmRleCIsImNvdW50IiwiYXJyIiwiaSIsInB1c2giLCJvYnNlcnZlRWxlbWVudFJlY3QiLCJpbnN0YW5jZSIsImNiIiwiZWxlbWVudCIsInNjcm9sbEVsZW1lbnQiLCJoYW5kbGVyIiwicmVjdCIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiYm9yZGVyQm94U2l6ZSIsImJveCIsImlubGluZVNpemUiLCJibG9ja1NpemUiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwib2JzZXJ2ZVdpbmRvd1JlY3QiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvYnNlcnZlRWxlbWVudE9mZnNldCIsIm9wdGlvbnMiLCJob3Jpem9udGFsIiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIm1lYXN1cmVFbGVtZW50Iiwic2l6ZSIsIndpbmRvd1Njcm9sbCIsIm9mZnNldCIsImFkanVzdG1lbnRzIiwiYmVoYXZpb3IiLCJfYSIsIl9iIiwidG9PZmZzZXQiLCJzY3JvbGxUbyIsImNhbGwiLCJlbGVtZW50U2Nyb2xsIiwiVmlydHVhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJ1bnN1YnMiLCJpc1Njcm9sbGluZyIsImlzU2Nyb2xsaW5nVGltZW91dElkIiwic2Nyb2xsVG9JbmRleFRpbWVvdXRJZCIsIm1lYXN1cmVtZW50c0NhY2hlIiwiaXRlbVNpemVDYWNoZSIsIk1hcCIsInBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyIsInNjcm9sbERpcmVjdGlvbiIsInNjcm9sbEFkanVzdG1lbnRzIiwibWVhc3VyZUVsZW1lbnRDYWNoZSIsIl9ybyIsImdldCIsImZvckVhY2giLCJfbWVhc3VyZUVsZW1lbnQiLCJ0YXJnZXQiLCJkaXNjb25uZWN0Iiwic2V0T3B0aW9ucyIsIm9wdHMyIiwiT2JqZWN0Iiwia2V5IiwidmFsdWUiLCJkZWJ1ZyIsImluaXRpYWxPZmZzZXQiLCJwYWRkaW5nU3RhcnQiLCJwYWRkaW5nRW5kIiwic2Nyb2xsUGFkZGluZ1N0YXJ0Iiwic2Nyb2xsUGFkZGluZ0VuZCIsImdldEl0ZW1LZXkiLCJyYW5nZUV4dHJhY3RvciIsIm9uQ2hhbmdlIiwiaW5pdGlhbFJlY3QiLCJzY3JvbGxNYXJnaW4iLCJzY3JvbGxpbmdEZWxheSIsImluZGV4QXR0cmlidXRlIiwiaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlIiwibGFuZXMiLCJub3RpZnkiLCJzeW5jIiwibWF5YmVOb3RpZnkiLCJjYWxjdWxhdGVSYW5nZSIsInByb2Nlc3MiLCJpbml0aWFsRGVwcyIsImNsZWFudXAiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZCIsIl9kaWRNb3VudCIsIl93aWxsVXBkYXRlIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIl9zY3JvbGxUb09mZnNldCIsInNjcm9sbE9mZnNldCIsInNjcm9sbFJlY3QiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0U2l6ZSIsIm1lbW9PcHRpb25zIiwiZ2V0RnVydGhlc3RNZWFzdXJlbWVudCIsIm1lYXN1cmVtZW50cyIsImZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQiLCJmdXJ0aGVzdE1lYXN1cmVtZW50cyIsIm0iLCJtZWFzdXJlbWVudCIsImhhcyIsImxhbmUiLCJwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQiLCJzZXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJnZXRNZWFzdXJlbWVudHMiLCJsZW5ndGgiLCJzbGljZSIsImZ1cnRoZXN0TWVhc3VyZW1lbnQiLCJtZWFzdXJlZFNpemUiLCJlc3RpbWF0ZVNpemUiLCJvdXRlclNpemUiLCJnZXRJbmRleGVzIiwiaW5kZXhGcm9tRWxlbWVudCIsIm5vZGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW5kZXhTdHIiLCJnZXRBdHRyaWJ1dGUiLCJjb25zb2xlIiwid2FybiIsInBhcnNlSW50IiwiaXRlbSIsImlzQ29ubmVjdGVkIiwiY2FjaGVkIiwiZGVsZXRlIiwicHJldk5vZGUiLCJtZWFzdXJlZEl0ZW1TaXplIiwicmVzaXplSXRlbSIsIml0ZW1TaXplIiwiZGVsdGEiLCJpbmZvIiwiZ2V0VmlydHVhbEl0ZW1zIiwiaW5kZXhlcyIsInZpcnR1YWxJdGVtcyIsImsiLCJsZW4iLCJnZXRWaXJ0dWFsSXRlbUZvck9mZnNldCIsImZpbmROZWFyZXN0QmluYXJ5U2VhcmNoIiwiZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50IiwiYWxpZ24iLCJzY3JvbGxTaXplUHJvcCIsInNjcm9sbFNpemUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIm1heE9mZnNldCIsImdldE9mZnNldEZvckluZGV4IiwiaXNEeW5hbWljTW9kZSIsImNhbmNlbFNjcm9sbFRvSW5kZXgiLCJzY3JvbGxUb09mZnNldCIsInNjcm9sbFRvSW5kZXgiLCJpbml0aWFsQWxpZ24iLCJlbGVtZW50SW5ET00iLCJ0b09mZnNldDIiLCJzY3JvbGxCeSIsImdldFRvdGFsU2l6ZSIsIm1hcCIsInNjcm9sbFRvRm4iLCJtZWFzdXJlIiwibG93IiwiaGlnaCIsImdldEN1cnJlbnRWYWx1ZSIsIm1pZGRsZSIsImN1cnJlbnRWYWx1ZSIsImdldE9mZnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n    let deps = opts.initialDeps ?? [];\n    let result;\n    return ()=>{\n        var _a, _b, _c, _d;\n        let depTime;\n        if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n        result = fn(...newDeps);\n        if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            const resultFpsPercentage = resultEndTime / 16;\n            const pad = (str, num)=>{\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n        }\n        (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n        return result;\n    };\n}\nfunction notUndefined(value, msg) {\n    if (value === void 0) {\n        throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n    } else {\n        return value;\n    }\n}\nconst approxEqual = (a, b)=>Math.abs(a - b) < 1;\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFTQSxLQUFLQyxPQUFPLEVBQUVDLEVBQUUsRUFBRUMsSUFBSTtJQUM3QixJQUFJQyxPQUFPRCxLQUFLRSxXQUFXLElBQUksRUFBRTtJQUNqQyxJQUFJQztJQUNKLE9BQU87UUFDTCxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQixJQUFJQztRQUNKLElBQUlSLEtBQUtTLEdBQUcsSUFBSyxFQUFDTCxLQUFLSixLQUFLVSxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlOLEdBQUdPLElBQUksQ0FBQ1gsS0FBSSxHQUNoRVEsVUFBVUksS0FBS0MsR0FBRztRQUNwQixNQUFNQyxVQUFVaEI7UUFDaEIsTUFBTWlCLGNBQWNELFFBQVFFLE1BQU0sS0FBS2YsS0FBS2UsTUFBTSxJQUFJRixRQUFRRyxJQUFJLENBQUMsQ0FBQ0MsS0FBS0MsUUFBVWxCLElBQUksQ0FBQ2tCLE1BQU0sS0FBS0Q7UUFDbkcsSUFBSSxDQUFDSCxhQUFhO1lBQ2hCLE9BQU9aO1FBQ1Q7UUFDQUYsT0FBT2E7UUFDUCxJQUFJTTtRQUNKLElBQUlwQixLQUFLUyxHQUFHLElBQUssRUFBQ0osS0FBS0wsS0FBS1UsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJTCxHQUFHTSxJQUFJLENBQUNYLEtBQUksR0FDaEVvQixhQUFhUixLQUFLQyxHQUFHO1FBQ3ZCVixTQUFTSixNQUFNZTtRQUNmLElBQUlkLEtBQUtTLEdBQUcsSUFBSyxFQUFDSCxLQUFLTixLQUFLVSxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlKLEdBQUdLLElBQUksQ0FBQ1gsS0FBSSxHQUFJO1lBQ3BFLE1BQU1xQixhQUFhQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1gsS0FBS0MsR0FBRyxLQUFLTCxPQUFNLElBQUssT0FBTztZQUM5RCxNQUFNZ0IsZ0JBQWdCRixLQUFLQyxLQUFLLENBQUMsQ0FBQ1gsS0FBS0MsR0FBRyxLQUFLTyxVQUFTLElBQUssT0FBTztZQUNwRSxNQUFNSyxzQkFBc0JELGdCQUFnQjtZQUM1QyxNQUFNRSxNQUFNLENBQUNDLEtBQUtDO2dCQUNoQkQsTUFBTUUsT0FBT0Y7Z0JBQ2IsTUFBT0EsSUFBSVgsTUFBTSxHQUFHWSxJQUFLO29CQUN2QkQsTUFBTSxNQUFNQTtnQkFDZDtnQkFDQSxPQUFPQTtZQUNUO1lBQ0FHLFFBQVFDLElBQUksQ0FDVixDQUFDLElBQUksRUFBRUwsSUFBSUYsZUFBZSxHQUFHLEVBQUUsRUFBRUUsSUFBSUwsWUFBWSxHQUFHLEdBQUcsQ0FBQyxFQUN4RCxDQUFDOzs7dUJBR2MsRUFBRUMsS0FBS1UsR0FBRyxDQUN2QixHQUNBVixLQUFLVyxHQUFHLENBQUMsTUFBTSxNQUFNUixxQkFBcUIsTUFDMUMsY0FBYyxDQUFDLEVBQ2pCekIsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS1MsR0FBRztRQUVwQztRQUNDRixDQUFBQSxLQUFLUCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLa0MsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJM0IsR0FBR0ksSUFBSSxDQUFDWCxNQUFNRztRQUM5RSxPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxTQUFTZ0MsYUFBYUMsS0FBSyxFQUFFQyxHQUFHO0lBQzlCLElBQUlELFVBQVUsS0FBSyxHQUFHO1FBQ3BCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLG9CQUFvQixFQUFFRCxNQUFNLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDaEUsT0FBTztRQUNMLE9BQU9EO0lBQ1Q7QUFDRjtBQUNBLE1BQU1HLGNBQWMsQ0FBQ0MsR0FBR0MsSUFBTW5CLEtBQUtvQixHQUFHLENBQUNGLElBQUlDLEtBQUs7QUFLOUMsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL3V0aWxzLmpzPzQ5NzIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IG9wdHMuaW5pdGlhbERlcHMgPz8gW107XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9hID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0cykpKVxuICAgICAgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9iID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0cykpKVxuICAgICAgcmVzdWx0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmVzdWx0ID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2MgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChvcHRzKSkpIHtcbiAgICAgIGNvbnN0IGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRGcHNQZXJjZW50YWdlID0gcmVzdWx0RW5kVGltZSAvIDE2O1xuICAgICAgY29uc3QgcGFkID0gKHN0ciwgbnVtKSA9PiB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgIHN0ciA9IFwiIFwiICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9O1xuICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICBgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLFxuICAgICAgICBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApXG4gICAgICAgICl9ZGVnIDEwMCUgMzElKTtgLFxuICAgICAgICBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleVxuICAgICAgKTtcbiAgICB9XG4gICAgKF9kID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwob3B0cywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gbm90VW5kZWZpbmVkKHZhbHVlLCBtc2cpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdW5kZWZpbmVkJHttc2cgPyBgOiAke21zZ31gIDogXCJcIn1gKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGFwcHJveEVxdWFsID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKSA8IDE7XG5leHBvcnQge1xuICBhcHByb3hFcXVhbCxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsibWVtbyIsImdldERlcHMiLCJmbiIsIm9wdHMiLCJkZXBzIiwiaW5pdGlhbERlcHMiLCJyZXN1bHQiLCJfYSIsIl9iIiwiX2MiLCJfZCIsImRlcFRpbWUiLCJrZXkiLCJkZWJ1ZyIsImNhbGwiLCJEYXRlIiwibm93IiwibmV3RGVwcyIsImRlcHNDaGFuZ2VkIiwibGVuZ3RoIiwic29tZSIsImRlcCIsImluZGV4IiwicmVzdWx0VGltZSIsImRlcEVuZFRpbWUiLCJNYXRoIiwicm91bmQiLCJyZXN1bHRFbmRUaW1lIiwicmVzdWx0RnBzUGVyY2VudGFnZSIsInBhZCIsInN0ciIsIm51bSIsIlN0cmluZyIsImNvbnNvbGUiLCJpbmZvIiwibWF4IiwibWluIiwib25DaGFuZ2UiLCJub3RVbmRlZmluZWQiLCJ2YWx1ZSIsIm1zZyIsIkVycm9yIiwiYXBwcm94RXF1YWwiLCJhIiwiYiIsImFicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;